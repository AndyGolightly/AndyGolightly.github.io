<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>notes4</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="https://samfearn.github.io/latex.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <script type="text/x-mathjax-config">
  	MathJax.Hub.Config({ TeX: { equationNumbers: {autoNumber: "ams"} } });
  	// I need to wait until MathJax has finished before running the numbering script
  	MathJax.Hub.Register.StartupHook("End",function(){doNumbering()});
  </script>
</head>
<body>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#preliminaries"><span class="toc-section-number">1</span> Preliminaries</a></li>
<li><a href="#the-metropolis-hastings-algorithm"><span class="toc-section-number">2</span> The Metropolis-Hastings algorithm</a></li>
<li><a href="#the-gibbs-sampler"><span class="toc-section-number">3</span> The Gibbs sampler</a></li>
<li><a href="#bayesian-inference-via-mcmc"><span class="toc-section-number">4</span> Bayesian Inference via MCMC</a>
<ul>
<li><a href="#application-i-normal-model-with-unknown-mean-and-precision"><span class="toc-section-number">4.1</span> Application I: Normal model with unknown mean and precision</a></li>
<li><a href="#application-ii-stochastic-volatility-model"><span class="toc-section-number">4.2</span> Application II: Stochastic volatility model</a></li>
</ul></li>
</ul>
</nav>
<section id="preliminaries" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Preliminaries</h1>
<p>See previous topic <a href="https://andygolightly.github.io/teaching/MATH3421/notes1">here</a>.</p>
</section>
<section id="the-metropolis-hastings-algorithm" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> The Metropolis-Hastings algorithm</h1>
<p>See previous topic <a href="https://andygolightly.github.io/teaching/MATH3421/notes2">here</a>.</p>
</section>
<section id="the-gibbs-sampler" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> The Gibbs sampler</h1>
<p>See previous topic <a href="https://andygolightly.github.io/teaching/MATH3421/notes3">here</a>.</p>
</section>
<section id="bayesian-inference-via-mcmc" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Bayesian Inference via MCMC</h1>
<p>In this chapter, we will consider the use of Metropolis-Hastings and the Gibbs sampler in two applications of increasing complexity.</p>
<section id="application-i-normal-model-with-unknown-mean-and-precision" class="level2" data-number="4.1">
<h2 data-number="4.1"><span class="header-section-number">4.1</span> Application I: Normal model with unknown mean and precision</h2>
<p>Reconsider the problem from Chapter 1 of Bayesian inference for the mean and precision of a normally distributed random sample. In particular, consider the non-conjugate approach based on the independent prior distributions for the mean and precision. We have that <span class="math display">\[\begin{aligned}
X_i | \mu, \tau &amp;\sim N(\mu, 1/\tau)\ \textrm{independently, for\ }i=1,\ldots,n\\
\tau&amp;\sim \textrm{Gamma}(g,h)\\
\mu&amp;\sim N(b,1/c).\end{aligned}\]</span> The joint posterior for <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\tau\)</span> based on a sample <span class="math inline">\(\boldsymbol{x}\)</span> of size <span class="math inline">\(n\)</span> can be written in terms of the sufficient statistics <span class="math display">\[\bar{x}=\frac{1}{n}\sum_1^n x_i\quad\textrm{and}\quad s^2 = \frac{1}{n}\sum_1^n (x_i-\bar{x})^2.\]</span> The posterior takes the form <span class="math display">\[\pi(\mu,\tau|\boldsymbol{x}) \propto
\tau^{\frac{n}{2}+g-1}
\exp\left\{-\frac{n\tau}{2}\left[ s^2 +(\bar{x}-\mu)^2\right] 
-h\tau -\frac{c}{2}(\mu-b)^2\right\}.\]</span> As explained previously, this distribution is non-standard, and the analysis is not conjugate.</p>
<p><strong>Setup</strong></p>
<ul>
<li><p>Suppose that we have observed data with <span class="math inline">\(n=100\)</span>, <span class="math inline">\(\bar{x}=12\)</span> and <span class="math inline">\(s^2=1\)</span>. Let us take <span class="math inline">\(\mu\sim N(10,100)\)</span> and <span class="math inline">\(\tau\sim Gamma(1,0.1)\)</span> <em>a priori</em>.</p></li>
<li><p>We will consider:</p>
<ul>
<li><p>A Gibbs sampler,</p></li>
<li><p>random walk Metropolis,</p></li>
<li><p>a Metropolis-Hastings independence sampler.</p></li>
</ul></li>
</ul>
<section id="gibbs-sampler" class="level3" data-number="4.1.1">
<h3 data-number="4.1.1"><span class="header-section-number">4.1.1</span> Gibbs sampler</h3>
<p>A <em>semi-conjugate</em> analysis is possible: the two conditional distributions <span class="math inline">\(\pi(\mu|\tau,\boldsymbol{x})\)</span> and <span class="math inline">\(\pi(\tau|\mu,\boldsymbol{x})\)</span> are of standard form, and are of the same form as the independent priors. In fact, <span class="math inline">\(\mu|\tau,\boldsymbol{x}\)</span> is Normally distributed and <span class="math inline">\(\tau|\mu,\boldsymbol{x}\)</span> is Gamma: <span class="math display">\[\begin{aligned}
\tau|\mu,\boldsymbol{x}&amp;\sim \textrm{Gamma}\left( g+\frac{n}{2}, 
h+\frac{n}{2}\left[ s^2+(\bar{x}-\mu)^2 \right] \right)\\
\mu|\tau,\boldsymbol{x}&amp;\sim N\left( \frac{bc+n\tau\bar{x}}{c+n\tau}, \frac{1}{c+n\tau} \right).\end{aligned}\]</span> It therefore seems natural to apply the Gibbs sampler to this problem. The (deterministic scan) Gibbs sampler takes the following form:</p>
<ol>
<li><p>Initialise the state of the chain <span class="math inline">\((\mu^{(0)},\tau^{(0)})&#39;\)</span> e.g. using the prior mean <span class="math inline">\((10,10)&#39;\)</span>. Initialise the iteration counter to <span class="math inline">\(j=1\)</span>.</p></li>
<li><p>Obtain a new values <span class="math inline">\(\mu^{(j)}\)</span> and <span class="math inline">\(\tau^{(j)}\)</span> from by successive generation of values</p>
<ul>
<li><p><span class="math inline">\(\mu^{(j)}\sim  N\left( \frac{bc+n\tau^{(j-1)}\bar{x}}{n\tau^{(j-1)}+c}, \frac{1}{n\tau^{(j-1)}+c} \right)\)</span></p></li>
<li><p><span class="math inline">\(\tau^{(j)}\sim \textrm{Gamma}\left( g+\frac{n}{2}, 
h+\frac{n}{2}\left[ s^2+(\bar{x}-\mu^{(j)})^2 \right] \right)\)</span></p></li>
</ul></li>
<li><p>If <span class="math inline">\(j=N\)</span> stop, otherwise change counter <span class="math inline">\(j\)</span> to <span class="math inline">\(j+1\)</span>, and return to step 2.</p></li>
</ol>
<p><strong>Gibbs sampler: R code</strong></p>
<div class="sourceCode" id="cb1" data-language="R"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">##Gibbs sampler</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a> gibbs=<span class="cf">function</span>(N,s,xbar,n,b,c,g,h)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a> {</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>  mat=<span class="kw">matrix</span>(<span class="dv">0</span>,<span class="dt">ncol=</span><span class="dv">2</span>,<span class="dt">nrow=</span>N) <span class="co">#store sampled mu and tau here</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>  mu=b</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>  tau=g<span class="op">/</span>h</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>  mat[<span class="dv">1</span>,]=<span class="kw">c</span>(mu,tau) <span class="co">#initialise at prior mean</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span>N)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>  {</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>   mu=<span class="kw">rnorm</span>(<span class="dv">1</span>,(b<span class="op">*</span>c<span class="op">+</span>n<span class="op">*</span>tau<span class="op">*</span>xbar)<span class="op">/</span>(n<span class="op">*</span>tau<span class="op">+</span>c),<span class="kw">sqrt</span>(<span class="dv">1</span><span class="op">/</span>(n<span class="op">*</span>tau<span class="op">+</span>c)))</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a>   tau=<span class="kw">rgamma</span>(<span class="dv">1</span>,g<span class="fl">+0.5</span><span class="op">*</span>n,h<span class="fl">+0.5</span><span class="op">*</span>n<span class="op">*</span>(s<span class="op">^</span><span class="dv">2</span><span class="op">+</span>(xbar<span class="op">-</span>mu)<span class="op">^</span><span class="dv">2</span>))</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a>   mat[i,]=<span class="kw">c</span>(mu,tau) <span class="co">#store</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a>  }</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a>  <span class="kw">return</span>(mat) </span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a> }</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a> </span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a> out=<span class="kw">gibbs</span>(<span class="dt">N=</span><span class="dv">5000</span>,<span class="dt">s=</span><span class="dv">1</span>,<span class="dt">xbar=</span><span class="dv">12</span>,<span class="dt">n=</span><span class="dv">100</span>,<span class="dt">b=</span><span class="dv">10</span>,<span class="dt">c=</span><span class="dv">1</span><span class="op">/</span><span class="dv">100</span>,<span class="dt">g=</span><span class="dv">1</span>,<span class="dt">h=</span><span class="fl">0.1</span>)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a> </span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true"></a> <span class="co">#Plots</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true"></a> </span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true"></a> <span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">3</span>))</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true"></a> <span class="kw">plot</span>(<span class="kw">ts</span>(out[<span class="dv">100</span><span class="op">:</span><span class="dv">5000</span>,<span class="dv">1</span>]),<span class="dt">main=</span><span class="st">&quot;mu&quot;</span>,<span class="dt">xlab=</span><span class="st">&quot;iteration&quot;</span>,<span class="dt">ylab=</span><span class="st">&quot;value&quot;</span>)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true"></a> <span class="kw">acf</span>(out[<span class="dv">100</span><span class="op">:</span><span class="dv">5000</span>,<span class="dv">1</span>],<span class="dt">main=</span><span class="st">&quot;&quot;</span>)</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true"></a> <span class="kw">hist</span>(out[<span class="dv">100</span><span class="op">:</span><span class="dv">5000</span>,<span class="dv">1</span>],<span class="dt">freq=</span>F,<span class="dt">main=</span><span class="st">&quot;mu&quot;</span>,<span class="dt">xlab=</span><span class="st">&quot;value&quot;</span>)</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true"></a> <span class="kw">plot</span>(<span class="kw">ts</span>(out[<span class="dv">100</span><span class="op">:</span><span class="dv">5000</span>,<span class="dv">2</span>]),<span class="dt">main=</span><span class="st">&quot;tau&quot;</span>,<span class="dt">xlab=</span><span class="st">&quot;iteration&quot;</span>,<span class="dt">ylab=</span><span class="st">&quot;value&quot;</span>)</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true"></a> <span class="kw">acf</span>(out[<span class="dv">100</span><span class="op">:</span><span class="dv">5000</span>,<span class="dv">2</span>],<span class="dt">main=</span><span class="st">&quot;&quot;</span>)</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true"></a> <span class="kw">hist</span>(out[<span class="dv">100</span><span class="op">:</span><span class="dv">5000</span>,<span class="dv">2</span>],<span class="dt">freq=</span>F,<span class="dt">main=</span><span class="st">&quot;tau&quot;</span>,<span class="dt">xlab=</span><span class="st">&quot;value&quot;</span>)</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true"></a> <span class="kw">plot</span>(<span class="kw">ts</span>(<span class="dv">1</span><span class="op">/</span><span class="kw">sqrt</span>(out[<span class="dv">100</span><span class="op">:</span><span class="dv">5000</span>,<span class="dv">2</span>])),<span class="dt">main=</span><span class="st">&quot;sigma&quot;</span>,<span class="dt">xlab=</span><span class="st">&quot;iteration&quot;</span>,<span class="dt">ylab=</span><span class="st">&quot;value&quot;</span>)</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true"></a> <span class="kw">acf</span>(<span class="dv">1</span><span class="op">/</span><span class="kw">sqrt</span>(out[<span class="dv">100</span><span class="op">:</span><span class="dv">5000</span>,<span class="dv">2</span>]),<span class="dt">main=</span><span class="st">&quot;&quot;</span>)</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true"></a> <span class="kw">hist</span>(<span class="dv">1</span><span class="op">/</span><span class="kw">sqrt</span>(out[<span class="dv">100</span><span class="op">:</span><span class="dv">5000</span>,<span class="dv">2</span>]),<span class="dt">freq=</span>F,<span class="dt">main=</span><span class="st">&quot;sigma&quot;</span>,<span class="dt">xlab=</span><span class="st">&quot;value&quot;</span>)</span></code></pre></div>
<p><strong>Gibbs sampler: output</strong></p>
<p> </p>
<table id="fig:figApp1Gibbs" class="imageTable">
<caption>Application I. Gibbs sampler output. </caption>
<tbody>
<tr class="odd">
<td style="text-align: center;"><embed src="../graphics/gibbs1.pdf" title="fig:" id="fig:figApp1Gibbs" style="width:15cm;height:6.5cm" /></td>
</tr>
<tr class="even">
<td style="text-align: center;"><embed src="../graphics/gibbs2.pdf" title="fig:" id="fig:figApp1Gibbs" style="width:15cm;height:6.5cm" /></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><embed src="../graphics/gibbs3.pdf" title="fig:" id="fig:figApp1Gibbs" style="width:15cm;height:6.5cm" /></td>
</tr>
</tbody>
</table>
</section>
<section id="random-walk-metropolis" class="level3" data-number="4.1.2">
<h3 data-number="4.1.2"><span class="header-section-number">4.1.2</span> Random walk Metropolis</h3>
<p>Suppose that we wish to sample <span class="math inline">\(\pi(\mu,\tau|\boldsymbol{x})\)</span> using a Metropolis-Hastings algorithm with a random walk proposal that uses Gaussian innovations. At this point, it is helpful to define <span class="math inline">\(\boldsymbol{\theta}=(\theta_{1},\theta_{2})&#39;=(\mu,\tau)&#39;\)</span>.</p>
<p>We will use a proposal of the form <span class="math display">\[\boldsymbol{\theta}^{*}=\boldsymbol{\theta}+\boldsymbol{w}, \qquad \boldsymbol{w}\sim N(\boldsymbol{0},V)\,.\]</span> Thus, <span class="math inline">\(\boldsymbol{\theta}^{*}\sim N(\boldsymbol{\theta},V)\)</span>. We therefore need to be able to simulate multivariate Normal random quantities. This is possible in R with <code>mvrnorm</code> which requires the MASS package, or alternatively we can devise our own algorithm. A simple way to generate <span class="math inline">\(d\)</span>-dimensional <span class="math inline">\(N(\boldsymbol{m},V)\)</span> random quantities using just univariate <span class="math inline">\(N(0,1)\)</span> realisations is as follows.</p>
<ol>
<li><p>Generate <span class="math inline">\(d\)</span> independent <span class="math inline">\(N(0,1)\)</span> realisations, <span class="math inline">\(z_{1},z_{2},\ldots ,z_{d}\)</span> and stack these in the <span class="math inline">\(d\times 1\)</span> vector <span class="math inline">\(\boldsymbol{z}\)</span>.</p></li>
<li><p>Find a matrix <span class="math inline">\(A\)</span> such that <span class="math inline">\(V=A&#39;A\)</span> (or <span class="math inline">\(V=AA&#39;\)</span>). For example, use the <em>Cholesky</em> decomposition so that <span class="math inline">\(A\)</span> is lower triangular. (The <code>chol()</code> function in R gives a matrix <span class="math inline">\(A\)</span> such that <span class="math inline">\(V=A&#39;A\)</span>.)</p></li>
<li><p>Take <span class="math inline">\(\boldsymbol{m}+A&#39;\boldsymbol{z}\)</span> as a <span class="math inline">\(N(\boldsymbol{m},V)\)</span> realisation.</p></li>
</ol>
<p>These steps can be implemented in R as follows.</p>
<div class="sourceCode" id="cb2" data-language="R"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="co">## Multivariate normal simulation</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a> </span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a> <span class="co">#simulate a N(m,V) random vector</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a> rmvn=<span class="cf">function</span>(m,V)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a> {</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>  d=<span class="kw">length</span>(m)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>  z=<span class="kw">rnorm</span>(d)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>  <span class="kw">return</span>(m<span class="op">+</span><span class="kw">t</span>(<span class="kw">chol</span>(V))<span class="op">%*%</span>z)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a> }</span></code></pre></div>
<p>The random walk Metropolis algorithm has the following form.</p>
<ol>
<li><p>Initialise the chain to <span class="math inline">\(\boldsymbol{\theta}^{(0)}=(10,10)&#39;\)</span>. Initialise the iteration counter to <span class="math inline">\(j=1\)</span>.</p></li>
<li><p>Generate a <em>proposed</em> value <span class="math display">\[\boldsymbol{\theta}^{*}\sim N(\boldsymbol{\theta}^{(j-1)},V)\,.\]</span></p></li>
<li><p>Evaluate the <em>acceptance probability</em> <span class="math inline">\(\alpha(\boldsymbol{\theta}^{*}|\boldsymbol{\theta}^{(j-1)})\)</span> of the proposed move, <span class="math display">\[\alpha(\boldsymbol{\theta}^{*}|\boldsymbol{\theta}^{(j-1)})=\textrm{min}\left\{ 1, 
\frac{\pi(\boldsymbol{\theta}^{*})\,f(\boldsymbol{x}|\boldsymbol{\theta}^{*})}{\pi(\boldsymbol{\theta}^{(j-1)})\,f(\boldsymbol{x}|\boldsymbol{\theta}^{(j-1)})}\right\}.\]</span></p></li>
<li><p>Put <span class="math inline">\(\boldsymbol{\theta}^{(j)}=\boldsymbol{\theta}^{*}\)</span> with probability <span class="math inline">\(\alpha(\boldsymbol{\theta}^{*}|\boldsymbol{\theta}^{(j-1)})\)</span>; otherwise put <span class="math inline">\(\boldsymbol{\theta}^{(j)}=\boldsymbol{\theta}^{(j-1)}\)</span>.</p></li>
<li><p>If <span class="math inline">\(j=N\)</span>, stop, otherwise put <span class="math inline">\(j\)</span> to <span class="math inline">\(j+1\)</span> and go to step 2.</p></li>
</ol>
<p>Recall that:</p>
<ul>
<li><p>The prior density is <span class="math inline">\(\pi(\boldsymbol{\theta})=\pi(\mu)\pi(\tau)\)</span> due to the independent prior specification.</p></li>
<li><p>The likelihood is <span class="math inline">\(f(\boldsymbol{x}|\boldsymbol{\theta})=\prod_{i=1}^n N(x_i; \mu,\tau^{-1})\)</span> (but recall that we’re given data summaries so we will implement the R code accordingly!)</p></li>
</ul>
<p><strong>Random walk Metropolis: R code</strong></p>
<div class="sourceCode" id="cb3" data-language="R"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="co">##Random walk Metropolis</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a> </span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a> <span class="co"># Function to evaluate the log of the posterior density</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a> <span class="co"># up to an additive constant</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a> </span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a> lpost=<span class="cf">function</span>(theta,s,xbar,n,b,c,g,h)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a> {</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>  mu=theta[<span class="dv">1</span>]</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>  tau=theta[<span class="dv">2</span>]</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>  logprior=<span class="kw">dnorm</span>(mu,b,<span class="kw">sqrt</span>(<span class="dv">1</span><span class="op">/</span>c),<span class="dt">log=</span>T)<span class="op">+</span><span class="kw">dgamma</span>(tau,g,h,<span class="dt">log=</span>T)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a>  loglike=(n<span class="op">/</span><span class="dv">2</span>)<span class="op">*</span><span class="kw">log</span>(tau)<span class="op">-</span>n<span class="op">*</span>tau<span class="op">/</span><span class="dv">2</span><span class="op">*</span>(s<span class="op">^</span><span class="dv">2</span><span class="op">+</span>(xbar<span class="op">-</span>mu)<span class="op">^</span><span class="dv">2</span>)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a>  logpost=logprior<span class="op">+</span>loglike</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a>  <span class="kw">return</span>(logpost)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true"></a> }</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true"></a> </span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true"></a> <span class="co"># Random walk Metropolis sampler -- uses lpost and rmvn</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true"></a> </span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true"></a> rwm=<span class="cf">function</span>(N,V,s,xbar,n,b,c,g,h) </span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true"></a> {</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true"></a>  mat=<span class="kw">matrix</span>(<span class="dv">0</span>,<span class="dt">ncol=</span><span class="dv">2</span>,<span class="dt">nrow=</span>N) <span class="co">#store sampled mu and tau here</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true"></a>  theta=<span class="kw">c</span>(b,g<span class="op">/</span>h)</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true"></a>  mat[<span class="dv">1</span>,]=theta    <span class="co">#initialise at prior mean</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span>N) </span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true"></a>  {</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true"></a>   can=<span class="kw">rmvn</span>(theta,V) <span class="co">#propose</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true"></a>   laprob=<span class="kw">lpost</span>(can,s,xbar,n,b,c,g,h)<span class="op">-</span><span class="kw">lpost</span>(theta,s,xbar,n,b,c,g,h)</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true"></a>   u=<span class="kw">runif</span>(<span class="dv">1</span>)</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true"></a>   <span class="cf">if</span> (<span class="kw">log</span>(u) <span class="op">&lt;</span><span class="st"> </span>laprob)</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true"></a>   { </span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true"></a>     theta=can</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true"></a>   }   </span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true"></a>   mat[i,]=theta</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true"></a>  } </span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true"></a>  <span class="kw">return</span>(mat)</span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true"></a> }</span></code></pre></div>
<p>Note that there’s a potential problem here! The sampler may propose a negative value of <span class="math inline">\(\tau\)</span>, which is fine in theory as this should just be rejected (as the support of <span class="math inline">\(\tau\)</span> <em>a posteriori</em> is the positive reals). However, the above function would give an error message. We can deal with this in one of two ways:</p>
<ol>
<li><p>Amend the code to reject any proposed moves for which <span class="math inline">\(\tau&lt;0\)</span> (before calling <code>lpost</code>.</p></li>
<li><p>Design a better Metropolis-Hastings sampler (e.g. one that works with <span class="math inline">\(\log(\tau)\)</span> rather than <span class="math inline">\(\tau\)</span>).</p></li>
</ol>
<p>To run the code, we need a suitable value of the tuning parameter <span class="math inline">\(V\)</span>. As we already have realisations of <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\tau\)</span> from the posterior (as given by the Gibbs sampler) let’s cheat (!) and take <span class="math display">\[V = \frac{2.38^2}{2}\widehat{Var}(\boldsymbol{\theta}|\boldsymbol{x})\,.\]</span> This can be achieved with</p>
<div class="sourceCode" id="cb4" data-language="R"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>postvar=<span class="kw">var</span>(out[<span class="dv">100</span><span class="op">:</span><span class="dv">5000</span>,])</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>vartune=(<span class="fl">2.38</span><span class="op">^</span><span class="dv">2</span><span class="op">/</span><span class="dv">2</span>)<span class="op">*</span>postvar</span></code></pre></div>
<p>In fact, for this example posterior correlation appears fairly low (<span class="math inline">\(\approx -0.018\)</span>) and so there is probably little to be gained by using a correlated (versus uncorrelated) random walk in this example. Now we’re ready to implement the algorithm.</p>
<div class="sourceCode" id="cb5" data-language="R"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>out2=<span class="kw">rwm</span>(<span class="dt">N=</span><span class="dv">5000</span>,<span class="dt">V=</span>postvar,<span class="dt">s=</span><span class="dv">1</span>,<span class="dt">xbar=</span><span class="dv">12</span>,<span class="dt">n=</span><span class="dv">100</span>,<span class="dt">b=</span><span class="dv">10</span>,<span class="dt">c=</span><span class="dv">1</span><span class="op">/</span><span class="dv">100</span>,<span class="dt">g=</span><span class="dv">1</span>,<span class="dt">h=</span><span class="fl">0.1</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a><span class="co">#Plots</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a><span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">3</span>))</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a><span class="kw">plot</span>(<span class="kw">ts</span>(out2[<span class="dv">500</span><span class="op">:</span><span class="dv">5000</span>,<span class="dv">1</span>]),<span class="dt">main=</span><span class="st">&quot;mu&quot;</span>,<span class="dt">xlab=</span><span class="st">&quot;iteration&quot;</span>,<span class="dt">ylab=</span><span class="st">&quot;value&quot;</span>)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a><span class="kw">acf</span>(out2[<span class="dv">500</span><span class="op">:</span><span class="dv">5000</span>,<span class="dv">1</span>],<span class="dt">main=</span><span class="st">&quot;&quot;</span>)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a><span class="kw">hist</span>(out2[<span class="dv">500</span><span class="op">:</span><span class="dv">5000</span>,<span class="dv">1</span>],<span class="dt">freq=</span>F,<span class="dt">main=</span><span class="st">&quot;mu&quot;</span>,<span class="dt">xlab=</span><span class="st">&quot;value&quot;</span>)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a><span class="kw">plot</span>(<span class="kw">ts</span>(out2[<span class="dv">500</span><span class="op">:</span><span class="dv">5000</span>,<span class="dv">2</span>]),<span class="dt">main=</span><span class="st">&quot;tau&quot;</span>,<span class="dt">xlab=</span><span class="st">&quot;iteration&quot;</span>,<span class="dt">ylab=</span><span class="st">&quot;value&quot;</span>)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a><span class="kw">acf</span>(out2[<span class="dv">500</span><span class="op">:</span><span class="dv">5000</span>,<span class="dv">2</span>],<span class="dt">main=</span><span class="st">&quot;&quot;</span>)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a><span class="kw">hist</span>(out2[<span class="dv">500</span><span class="op">:</span><span class="dv">5000</span>,<span class="dv">2</span>],<span class="dt">freq=</span>F,<span class="dt">main=</span><span class="st">&quot;tau&quot;</span>,<span class="dt">xlab=</span><span class="st">&quot;value&quot;</span>)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a><span class="kw">plot</span>(<span class="kw">ts</span>(<span class="dv">1</span><span class="op">/</span><span class="kw">sqrt</span>(out2[<span class="dv">500</span><span class="op">:</span><span class="dv">5000</span>,<span class="dv">2</span>])),<span class="dt">main=</span><span class="st">&quot;sigma&quot;</span>,<span class="dt">xlab=</span><span class="st">&quot;iteration&quot;</span>,<span class="dt">ylab=</span><span class="st">&quot;value&quot;</span>)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a><span class="kw">acf</span>(<span class="dv">1</span><span class="op">/</span><span class="kw">sqrt</span>(out2[<span class="dv">500</span><span class="op">:</span><span class="dv">5000</span>,<span class="dv">2</span>]),<span class="dt">main=</span><span class="st">&quot;&quot;</span>)</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a><span class="kw">hist</span>(<span class="dv">1</span><span class="op">/</span><span class="kw">sqrt</span>(out2[<span class="dv">500</span><span class="op">:</span><span class="dv">5000</span>,<span class="dv">2</span>]),<span class="dt">freq=</span>F,<span class="dt">main=</span><span class="st">&quot;sigma&quot;</span>,<span class="dt">xlab=</span><span class="st">&quot;value&quot;</span>)</span></code></pre></div>
<p><strong>Random walk Metropolis: output</strong></p>
<p>The usual trace and acf plots can be seen below. The mixing is adequate, although apparently not as good as for the Gibbs sampler. In fact, the <em>minimum effective sample size</em> (ESS, with the minimum taken over each parameter chain) for the Gibbs sampler is 4900 versus 87 for random walk Metropolis, suggesting that a longer run of the latter is required.</p>
<table id="fig:figApp1RWM" class="imageTable">
<caption>Application I. Random walk Metropolis output. </caption>
<tbody>
<tr class="odd">
<td style="text-align: center;"><embed src="../graphics/rwm1.pdf" title="fig:" id="fig:figApp1RWM" style="width:15cm;height:6.5cm" /></td>
</tr>
<tr class="even">
<td style="text-align: center;"><embed src="../graphics/rwm2.pdf" title="fig:" id="fig:figApp1RWM" style="width:15cm;height:6.5cm" /></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><embed src="../graphics/rwm3.pdf" title="fig:" id="fig:figApp1RWM" style="width:15cm;height:6.5cm" /></td>
</tr>
</tbody>
</table>
</section>
<section id="independence-sampler" class="level3" data-number="4.1.3">
<h3 data-number="4.1.3"><span class="header-section-number">4.1.3</span> Independence sampler</h3>
<p>Finally, suppose that we wish to sample <span class="math inline">\(\pi(\mu,\tau|\boldsymbol{x})\)</span> using a Metropolis-Hastings algorithm with an independence proposal given by the prior. That is, candidate values of <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\tau\)</span> are drawn from <span class="math inline">\(\pi(\mu,\tau)=\pi(\mu)\pi(\tau)\)</span>. The algorithm is as follows.</p>
<ol>
<li><p>Initialise the chain to <span class="math inline">\(\boldsymbol{\theta}^{(0)}=(10,10)&#39;\)</span>. Initialise the iteration counter to <span class="math inline">\(j=1\)</span>.</p></li>
<li><p>Generate a <em>proposed</em> value <span class="math display">\[\theta^{*}_{1}\sim N(10,100)\qquad \textrm{and}\qquad \theta^{*}_{2}\sim Gamma(1,0.1).\]</span></p></li>
<li><p>Evaluate the <em>acceptance probability</em> <span class="math inline">\(\alpha(\boldsymbol{\theta}^{*}|\boldsymbol{\theta}^{(j-1)})\)</span> of the proposed move, <span class="math display">\[\alpha(\boldsymbol{\theta}^{*}|\boldsymbol{\theta}^{(j-1)})=\textrm{min}\left\{ 1, 
\frac{f(\boldsymbol{x}|\boldsymbol{\theta}^{*})}{f(\boldsymbol{x}|\boldsymbol{\theta}^{(j-1)})}\right\}.\]</span></p></li>
<li><p>Put <span class="math inline">\(\boldsymbol{\theta}^{(j)}=\boldsymbol{\theta}^{*}\)</span> with probability <span class="math inline">\(\alpha(\boldsymbol{\theta}^{*}|\boldsymbol{\theta}^{(j-1)})\)</span>; otherwise put <span class="math inline">\(\boldsymbol{\theta}^{(j)}=\boldsymbol{\theta}^{(j-1)}\)</span>.</p></li>
<li><p>Put If <span class="math inline">\(j=N\)</span>, stop, otherwise set <span class="math inline">\(j\)</span> to <span class="math inline">\(j+1\)</span> and go to step 2.</p></li>
</ol>
<p><strong>Independence sampler: R code</strong></p>
<div class="sourceCode" id="cb6" data-language="R"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="co">##Independence sampler</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a> </span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a> <span class="co"># Function to evaluate log-likelihood up to an additive constant</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a> </span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a> llike=<span class="cf">function</span>(theta,s,xbar,n)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a> {</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>  mu=theta[<span class="dv">1</span>]</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>  tau=theta[<span class="dv">2</span>]</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>  loglike=(n<span class="op">/</span><span class="dv">2</span>)<span class="op">*</span><span class="kw">log</span>(tau)<span class="op">-</span>n<span class="op">*</span>tau<span class="op">/</span><span class="dv">2</span><span class="op">*</span>(s<span class="op">^</span><span class="dv">2</span><span class="op">+</span>(xbar<span class="op">-</span>mu)<span class="op">^</span><span class="dv">2</span>)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>  <span class="kw">return</span>(loglike)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a> }</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a> </span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a> <span class="co"># Indepence sampler</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a> </span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a> mh=<span class="cf">function</span> (N,s,xbar,n,b,c,g,h) </span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true"></a> {</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true"></a>  can=<span class="kw">rep</span>(<span class="dv">0</span>,<span class="dv">2</span>)</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true"></a>  mat=<span class="kw">matrix</span>(<span class="dv">0</span>,<span class="dt">ncol=</span><span class="dv">2</span>,<span class="dt">nrow=</span>N) <span class="co">#store sampled mu and tau here</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true"></a>  theta=<span class="kw">c</span>(b,g<span class="op">/</span>h)</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true"></a>  mat[<span class="dv">1</span>,]=theta <span class="co">#initialise at prior mean</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span>N) </span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true"></a>  {</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true"></a>   can[<span class="dv">1</span>] =<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>,b,<span class="kw">sqrt</span>(<span class="dv">1</span><span class="op">/</span>c))</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true"></a>   can[<span class="dv">2</span>] =<span class="st"> </span><span class="kw">rgamma</span>(<span class="dv">1</span>,g,h) <span class="co">#propose from prior</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true"></a>   laprob =<span class="st"> </span><span class="kw">llike</span>(can,s,xbar,n)<span class="op">-</span><span class="kw">llike</span>(theta,s,xbar,n)</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true"></a>   u =<span class="st"> </span><span class="kw">runif</span>(<span class="dv">1</span>)</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true"></a>   <span class="cf">if</span> (<span class="kw">log</span>(u) <span class="op">&lt;</span><span class="st"> </span>laprob)</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true"></a>   { </span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true"></a>     theta =<span class="st"> </span>can</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true"></a>   }   </span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true"></a>   mat[i,] =<span class="st"> </span>theta</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true"></a>  } </span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true"></a>  <span class="kw">return</span>(mat)</span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true"></a> }</span></code></pre></div>
<p>We then call the <code>mh</code> function as follows. Note the number of iterations (<span class="math inline">\(N=500,000\)</span>) and the output is <em>thinned</em><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> so that the subsequent plots are based on <span class="math inline">\(5,000\)</span> samples.</p>
<div class="sourceCode" id="cb7" data-language="R"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>out3=<span class="kw">mh</span>(<span class="dt">N=</span><span class="dv">500000</span>,<span class="dt">s=</span><span class="dv">1</span>,<span class="dt">xbar=</span><span class="dv">12</span>,<span class="dt">n=</span><span class="dv">100</span>,<span class="dt">b=</span><span class="dv">10</span>,<span class="dt">c=</span><span class="dv">1</span><span class="op">/</span><span class="dv">100</span>,<span class="dt">g=</span><span class="dv">1</span>,<span class="dt">h=</span><span class="fl">0.1</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a> </span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a> <span class="co">#Plots</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a> </span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a> <span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">3</span>))</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a> <span class="kw">plot</span>(<span class="kw">ts</span>(out3[(<span class="dv">1</span><span class="op">:</span><span class="dv">5000</span>)<span class="op">*</span><span class="dv">100</span>,<span class="dv">1</span>]),<span class="dt">main=</span><span class="st">&quot;mu&quot;</span>,<span class="dt">xlab=</span><span class="st">&quot;iteration&quot;</span>,<span class="dt">ylab=</span><span class="st">&quot;value&quot;</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a> <span class="kw">acf</span>(out3[(<span class="dv">1</span><span class="op">:</span><span class="dv">5000</span>)<span class="op">*</span><span class="dv">100</span>,<span class="dv">1</span>],<span class="dt">main=</span><span class="st">&quot;&quot;</span>)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a> <span class="kw">hist</span>(out3[(<span class="dv">1</span><span class="op">:</span><span class="dv">5000</span>)<span class="op">*</span><span class="dv">100</span>,<span class="dv">1</span>],<span class="dt">freq=</span>F,<span class="dt">main=</span><span class="st">&quot;mu&quot;</span>,<span class="dt">xlab=</span><span class="st">&quot;value&quot;</span>)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a> <span class="kw">plot</span>(<span class="kw">ts</span>(out3[(<span class="dv">1</span><span class="op">:</span><span class="dv">5000</span>)<span class="op">*</span><span class="dv">100</span>,<span class="dv">2</span>]),<span class="dt">main=</span><span class="st">&quot;tau&quot;</span>,<span class="dt">xlab=</span><span class="st">&quot;iteration&quot;</span>,<span class="dt">ylab=</span><span class="st">&quot;value&quot;</span>)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a> <span class="kw">acf</span>(out3[(<span class="dv">1</span><span class="op">:</span><span class="dv">5000</span>)<span class="op">*</span><span class="dv">100</span>,<span class="dv">2</span>],<span class="dt">main=</span><span class="st">&quot;&quot;</span>)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a> <span class="kw">hist</span>(out3[(<span class="dv">1</span><span class="op">:</span><span class="dv">5000</span>)<span class="op">*</span><span class="dv">100</span>,<span class="dv">2</span>],<span class="dt">freq=</span>F,<span class="dt">main=</span><span class="st">&quot;tau&quot;</span>,<span class="dt">xlab=</span><span class="st">&quot;value&quot;</span>)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a> <span class="kw">plot</span>(<span class="kw">ts</span>(<span class="dv">1</span><span class="op">/</span><span class="kw">sqrt</span>(out3[(<span class="dv">1</span><span class="op">:</span><span class="dv">5000</span>)<span class="op">*</span><span class="dv">100</span>,<span class="dv">2</span>])),<span class="dt">main=</span><span class="st">&quot;sigma&quot;</span>,<span class="dt">xlab=</span><span class="st">&quot;iteration&quot;</span>,<span class="dt">ylab=</span><span class="st">&quot;value&quot;</span>)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a> <span class="kw">acf</span>(<span class="dv">1</span><span class="op">/</span><span class="kw">sqrt</span>(out3[(<span class="dv">1</span><span class="op">:</span><span class="dv">5000</span>)<span class="op">*</span><span class="dv">100</span>,<span class="dv">2</span>]),<span class="dt">main=</span><span class="st">&quot;&quot;</span>)</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a> <span class="kw">hist</span>(<span class="dv">1</span><span class="op">/</span><span class="kw">sqrt</span>(out3[(<span class="dv">1</span><span class="op">:</span><span class="dv">5000</span>)<span class="op">*</span><span class="dv">100</span>,<span class="dv">2</span>]),<span class="dt">freq=</span>F,<span class="dt">main=</span><span class="st">&quot;sigma&quot;</span>,<span class="dt">xlab=</span><span class="st">&quot;value&quot;</span>)</span></code></pre></div>
<p><strong>Independence sampler: output</strong></p>
<p>The usual trace and acf plots can be seen below. Note that the mixing is poor, despite a very long. The minimum ESS calculated from the thinned sample is around 200. This is not the full story! The time taken to run the sampler on my laptop is around 8s. Hence the minimum ESS/s is 200/8 versus 87/0.17 for the random walk Metropolis algorithm. The problem with the independence sampler used here is that the prior is quite diffuse compared to the posterior, so most proposed parameter values are rejected, leading to a small acceptance probability.</p>
<p><embed src="../graphics/mh1.pdf" title="fig:" id="fig:figAppIindS" style="width:15cm;height:6.5cm" /> <embed src="../graphics/mh2.pdf" title="fig:" id="fig:figAppIindS" style="width:15cm;height:6.5cm" /> <embed src="../graphics/mh3.pdf" title="fig:" id="fig:figAppIindS" style="width:15cm;height:6.5cm" /></p>
</section>
</section>
<section id="application-ii-stochastic-volatility-model" class="level2" data-number="4.2">
<h2 data-number="4.2"><span class="header-section-number">4.2</span> Application II: Stochastic volatility model</h2>
<p>In this section we consider the problem of modelling an asset’s price. Let <span class="math inline">\(Y_0^*,Y_1^*,\ldots,Y_n^*\)</span> be (daily) readings of some quantity such as share price of a given company. Define <span class="math inline">\(Y_t=\log Y_{t}^*-\log Y_{t-1}^*\)</span> be be the logarithm of the relative change in share value since the previous day. These daily differences often exhibit changes in variability. To see this consider the <em>Standard and Poors 500</em> index, for which a snapshot of the raw index and daily differences are plotted below.</p>
<div class="center">
<figure>
<embed src="../graphics/sp500.pdf" id="fig:figSP" style="width:15cm;height:8cm" /><figcaption aria-hidden="true">S&amp; P 500 data. Left panel: raw index. Right panel: log differences.</figcaption>
</figure>
</div>
<p>Clearly, the day-to-day variability (known in the financial time-series context as <em>volatility</em>) is not constant through time. One commonly used model to capture this behaviour is the <em>stochastic volatility model</em> given by <span class="math display">\[\begin{aligned}
X_0 &amp;\sim N\left(0,\, \frac{\sigma^2}{1-\phi^2} \right),\\
X_t|X_{t-1}=x_{t-1} &amp;\sim N\left(\phi x_{t-1},\, \sigma^2  \right),\\
Y_{t}|X_{t}=x_t &amp;\sim N\left(0,\, \kappa^2\exp\{x_t\} \right),\end{aligned}\]</span> for <span class="math inline">\(t=1,\ldots,n\)</span>. Plainly, <span class="math inline">\(\{X_t\}_{t=0}^{n}\)</span> is the AR(1) process that we looked at in Chapter 1 when examining Markov chains with continuous state space. Note that here it is started from its stationary distribution.</p>
<section id="inference-for-latent-variable-models" class="level3" data-number="4.2.1">
<h3 data-number="4.2.1"><span class="header-section-number">4.2.1</span> Inference for latent variable models</h3>
<p>Note that in practice, we observe <span class="math inline">\(\boldsymbol{y}=(y_1,\ldots,y_n)&#39;\)</span> but NOT <span class="math inline">\(\boldsymbol{x}=(x_0,x_1,\ldots,x_n)&#39;\)</span>. Let <span class="math inline">\(\boldsymbol{\theta}=(\phi,\sigma,\kappa)&#39;\)</span> denote the parameter vector of interest. The <em>observed data likelihood</em> is given by <span class="math display">\[\begin{aligned}
f(\boldsymbol{y}|\boldsymbol{\theta}) &amp;= \int f(\boldsymbol{y},\boldsymbol{x}|\boldsymbol{\theta})d\boldsymbol{x}\\
&amp;= \int f(\boldsymbol{y}|\boldsymbol{x},\boldsymbol{\theta}) f(\boldsymbol{x}|\boldsymbol{\theta}) d\boldsymbol{x}.\end{aligned}\]</span> Typically, this integral is high dimensional and intractable.</p>
<p>We deal with this problem in the Bayesian paradigm by formulating the joint posterior density for <span class="math inline">\(\boldsymbol{\theta}\)</span> and <span class="math inline">\(\boldsymbol{x}\)</span> as <span class="math display">\[\begin{aligned}
\pi(\boldsymbol{\theta},\boldsymbol{x}|\boldsymbol{y}) &amp;\propto \pi(\boldsymbol{\theta}) f(\boldsymbol{y},\boldsymbol{x}|\boldsymbol{\theta})\\
&amp;\propto \pi(\boldsymbol{\theta})f(\boldsymbol{y}|\boldsymbol{x},\boldsymbol{\theta}) f(\boldsymbol{x}|\boldsymbol{\theta}).\end{aligned}\]</span> We then generate samples from this joint posterior using MCMC. If interest is only in <span class="math inline">\(\boldsymbol{\theta}\)</span> then we only retain parameter samples when running the MCMC scheme.</p>
<p>For the stochastic volatility model we have that <span class="math display">\[f(\boldsymbol{y},\boldsymbol{x}|\boldsymbol{\theta})= N\left(x_0;\,0,\, \frac{\sigma^2}{1-\phi^2} \right)
\prod_{t=1}^n N\left(x_t;\,\phi x_{t-1},\, \sigma^2  \right)\times 
\prod_{t=1}^n N\left(y_t;\,0,\, \kappa^2\exp\{x_t\}\right).\]</span></p>
</section>
<section id="mcmc-sampler" class="level3" data-number="4.2.2">
<h3 data-number="4.2.2"><span class="header-section-number">4.2.2</span> MCMC sampler</h3>
<p>To make the MCMC scheme more efficient, we will work with the transformed parameters <span class="math display">\[\begin{aligned}
\theta_1 &amp;=\log[\phi/(1-\phi)],\\
\theta_2 &amp;= \log\sigma,\\
\theta_3 &amp;= \log\kappa.\end{aligned}\]</span></p>
<p>We will use <em>simulated data</em> which were generated using ground truth values of <span class="math inline">\((\phi,\sigma,\kappa)=(0.9,0.1,0.5)\)</span>. Hence <span class="math inline">\(\boldsymbol{\theta}\approx (-0.105,-2.303,-0.693)\)</span>. The code for generating and plotting the data is as follows.</p>
<div class="sourceCode" id="cb8" data-language="R"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="co">## Generate synthetic data</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a> </span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a> <span class="kw">set.seed</span>(<span class="dv">3421</span>)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a> x=<span class="dv">0</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a> nt=<span class="dv">100</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a> xs=<span class="kw">rep</span>(<span class="dv">0</span>,nt<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a> xs[<span class="dv">1</span>]=x; ydata=<span class="kw">rep</span>(<span class="dv">0</span>,nt)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a> <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>nt) </span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a> {</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>  x=<span class="fl">0.9</span><span class="op">*</span>x<span class="op">+</span><span class="kw">rnorm</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="fl">0.1</span>)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>  xs[i<span class="op">+</span><span class="dv">1</span>]=x</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a>  ydata[i]=<span class="kw">rnorm</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="fl">0.5</span><span class="op">*</span><span class="kw">exp</span>(<span class="fl">0.5</span><span class="op">*</span>x))</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a> }</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a> </span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true"></a> <span class="co">## Plot</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true"></a> </span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true"></a> <span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true"></a> <span class="kw">plot</span>(<span class="kw">ts</span>(xs,<span class="dt">start=</span><span class="dv">0</span>,<span class="dt">deltat=</span><span class="dv">1</span>),<span class="dt">ylab=</span><span class="st">&quot;Xt&quot;</span>,<span class="dt">xlab=</span><span class="st">&quot;Day&quot;</span>)</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true"></a> <span class="kw">plot</span>(<span class="kw">ts</span>(ydata,<span class="dt">start=</span><span class="dv">0</span>,<span class="dt">deltat=</span><span class="dv">1</span>),<span class="dt">ylab=</span><span class="st">&quot;Yt&quot;</span>,<span class="dt">xlab=</span><span class="st">&quot;Day&quot;</span>)</span></code></pre></div>
<p>The data consist of 100 observations <span class="math inline">\(y_1,\ldots, y_{100}\)</span> and are plotted above, with the corresponding values <span class="math inline">\(x_0,x_1,\ldots,x_{100}\)</span>.</p>
<div class="center">
<figure>
<embed src="../graphics/App2data.pdf" id="fig:figApp2data" style="width:15cm;height:8cm" /><figcaption aria-hidden="true">Application II. Synthetic data. Left panel: <span class="math inline">\(X_t\)</span> (unobserved). Right panel: <span class="math inline">\(Y_t\)</span> (observed).</figcaption>
</figure>
</div>
<p>We adopt an independent prior specification and take <span class="math inline">\(\theta_1\sim N(2,0.1)\)</span>, <span class="math inline">\(\theta_2\sim N(0,1)\)</span> and <span class="math inline">\(\theta_3\sim N(0,100)\)</span>. The following two R functions can be used to evaluate the log-prior <span class="math inline">\(\log \pi(\boldsymbol{\theta})\)</span> and log-likelihood <span class="math inline">\(\log f(\boldsymbol{y},\boldsymbol{x}|\boldsymbol{\theta})\)</span>.</p>
<div class="sourceCode" id="cb9" data-language="R"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="co">## Function to evaluate log-prior</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a> </span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a> lprior=<span class="cf">function</span>(theta)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a> {</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>  <span class="kw">return</span>(<span class="kw">sum</span>(<span class="kw">dnorm</span>(theta,<span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">0</span>),<span class="kw">sqrt</span>(<span class="kw">c</span>(<span class="fl">0.1</span>,<span class="dv">1</span>,<span class="dv">100</span>)),<span class="dt">log=</span><span class="ot">TRUE</span>)))</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a> }</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a> </span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a> <span class="co">## Function to evaluate log-likelihood</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a> </span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a> llike=<span class="cf">function</span>(theta,data,xproc)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a> {</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a>  phi=<span class="kw">exp</span>(theta[<span class="dv">1</span>])<span class="op">/</span>(<span class="dv">1</span><span class="op">+</span><span class="kw">exp</span>(theta[<span class="dv">1</span>]))</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true"></a>  sigma=<span class="kw">exp</span>(theta[<span class="dv">2</span>])</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true"></a>  kappa=<span class="kw">exp</span>(theta[<span class="dv">3</span>])</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true"></a>  ny=<span class="kw">length</span>(data)</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true"></a>  </span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true"></a>  init=<span class="kw">dnorm</span>(xproc[<span class="dv">1</span>],<span class="dv">0</span>,sigma<span class="op">/</span><span class="kw">sqrt</span>(<span class="dv">1</span><span class="op">-</span>phi<span class="op">^</span><span class="dv">2</span>),<span class="dt">log=</span><span class="ot">TRUE</span>)</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true"></a>  fx=<span class="kw">sum</span>(<span class="kw">dnorm</span>(xproc[<span class="dv">2</span><span class="op">:</span>(ny<span class="op">+</span><span class="dv">1</span>)],phi<span class="op">*</span>xproc[<span class="dv">1</span><span class="op">:</span>ny],sigma,<span class="dt">log=</span><span class="ot">TRUE</span>))</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true"></a>  fy=<span class="kw">sum</span>(<span class="kw">dnorm</span>(data,<span class="dv">0</span>,kappa<span class="op">*</span><span class="kw">exp</span>(<span class="fl">0.5</span><span class="op">*</span>xproc[<span class="dv">2</span><span class="op">:</span>(ny<span class="op">+</span><span class="dv">1</span>)]),<span class="dt">log=</span><span class="ot">TRUE</span>))</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true"></a> </span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true"></a>  <span class="kw">return</span>(init<span class="op">+</span>fx<span class="op">+</span>fy)    </span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true"></a> }</span></code></pre></div>
<p>The MCMC sampler we will use updates <span class="math inline">\(\boldsymbol{\theta}\)</span> and <span class="math inline">\(\boldsymbol{x}\)</span> in separate blocks, via random walk proposals. Hence, each iteration of the scheme has two parts:</p>
<ul>
<li><p>Update <span class="math inline">\(\boldsymbol{\theta}|\boldsymbol{x},\boldsymbol{y}\)</span> via a 3-dimensional random walk Metropolis move, with proposal <span class="math inline">\(\boldsymbol{\theta}^*\sim N(\boldsymbol{\theta},V)\)</span> where <span class="math inline">\(V=\lambda_1^2 I_3\)</span>. The scaling <span class="math inline">\(\lambda_1\)</span> is chosen to achieve an acceptance rate of approximately <span class="math inline">\(30\%\)</span>.</p></li>
<li><p>Update <span class="math inline">\(\boldsymbol{x}|\boldsymbol{\theta},\boldsymbol{y}\)</span> via an <span class="math inline">\(n+1\)</span>-dimensional random walk Metropolis move, with a proposal of <span class="math inline">\(\boldsymbol{x}^*\sim N(\boldsymbol{x},\lambda_2^2 B)\)</span>, where <span class="math inline">\(B\)</span> is the variance matrix of an AR(1) process with <span class="math inline">\(\sigma=0.1\)</span> and <span class="math inline">\(\phi=0.9\)</span>. The scaling <span class="math inline">\(\lambda_2\)</span> is chosen to achieve an acceptance rate of approximately <span class="math inline">\(25\%\)</span>.</p></li>
</ul>
<p>Now, using that for a stationary AR(1) process, <span class="math display">\[Cov(X_s,X_t)=\frac{\sigma^2}{1-\phi^2}\phi^{|s-t|}\]</span> we use the following code to set <span class="math inline">\(V\)</span> and <span class="math inline">\(B\)</span>.</p>
<div class="sourceCode" id="cb10" data-language="R"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="co">## Generate initial tuning matrix for theta update</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a> </span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a> V=<span class="kw">diag</span>(<span class="kw">rep</span>(<span class="fl">0.05</span>,<span class="dv">3</span>)) <span class="co"># diagonal matrix</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a> </span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a> <span class="co">## Generate initial tuning matrix for x update</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a> </span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a> phi=<span class="fl">0.9</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a> sigma=<span class="fl">0.1</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a> times=<span class="kw">seq</span>(<span class="dv">0</span>,<span class="kw">length</span>(ydata),<span class="dv">1</span>)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a> B=<span class="fl">0.05</span><span class="op">*</span>sigma<span class="op">^</span><span class="dv">2</span><span class="op">/</span>(<span class="dv">1</span><span class="op">-</span>phi<span class="op">^</span><span class="dv">2</span>)<span class="op">*</span>phi<span class="op">^</span><span class="kw">abs</span>(<span class="kw">outer</span>(times,times,<span class="st">&quot;-&quot;</span>))</span></code></pre></div>
<p>Finally, the Metropolis sampler can be implemented via the following R function.</p>
<div class="sourceCode" id="cb11" data-language="R"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>metropolis=<span class="cf">function</span>(N,data,Vtune,Btune,theta0,x0)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a> {</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>  ny=<span class="kw">length</span>(data)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>  mat=<span class="kw">matrix</span>(<span class="dv">0</span>,<span class="dt">nrow=</span>N,<span class="dt">ncol=</span><span class="dv">3</span>) <span class="co"># store theta samples here</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>  matX=<span class="kw">matrix</span>(<span class="dv">0</span>,<span class="dt">nrow=</span>N,<span class="dt">ncol=</span>ny<span class="op">+</span><span class="dv">1</span>) <span class="co"># store x samples here</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>  <span class="co">#Initialise</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a>  theta=theta0</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a>  mat[<span class="dv">1</span>,]=theta</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a>  x=x0</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a>  matX[<span class="dv">1</span>,]=x0</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a>  count1=<span class="dv">0</span>; count2=<span class="dv">0</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true"></a> </span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span>N)</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true"></a>  {</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true"></a>   <span class="co">#update parameters</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true"></a>   can=<span class="kw">rmvn</span>(theta,Vtune)</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true"></a>   laprob=<span class="kw">lprior</span>(can)<span class="op">+</span><span class="kw">llike</span>(can,data,x)<span class="op">-</span><span class="kw">lprior</span>(theta)<span class="op">-</span><span class="kw">llike</span>(theta,data,x)</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true"></a>   u=<span class="kw">runif</span>(<span class="dv">1</span>)</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true"></a>   <span class="cf">if</span> (<span class="kw">log</span>(u) <span class="op">&lt;</span><span class="st"> </span>laprob)</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true"></a>   { </span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true"></a>    theta=can</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true"></a>    count1=count1<span class="op">+</span><span class="dv">1</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true"></a>   }   </span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true"></a>   mat[i,]=theta</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true"></a> </span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true"></a>   <span class="co">#update x process</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true"></a>   xcan=<span class="kw">rmvn</span>(x,Btune)</span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true"></a>   laprob=<span class="kw">llike</span>(theta,data,xcan)<span class="op">-</span><span class="kw">llike</span>(theta,data,x)</span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true"></a>   u=<span class="kw">runif</span>(<span class="dv">1</span>)</span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true"></a>   <span class="cf">if</span> (<span class="kw">log</span>(u) <span class="op">&lt;</span><span class="st"> </span>laprob)</span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true"></a>   { </span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true"></a>    x=xcan</span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true"></a>    count2=count2<span class="op">+</span><span class="dv">1</span></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true"></a>   }   </span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true"></a>   matX[i,]=x</span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true"></a>  }</span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true"></a>  <span class="kw">print</span>(<span class="kw">c</span>(count1<span class="op">/</span>(N<span class="dv">-1</span>),count2<span class="op">/</span>(N<span class="dv">-1</span>)))</span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true"></a>  <span class="kw">return</span>(<span class="kw">list</span>(mat,matX))</span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true"></a> }</span></code></pre></div>
<p>We call the function with <span class="math inline">\(N=50,000\)</span> iterations, and <span class="math inline">\(\boldsymbol{\theta}\)</span> and <span class="math inline">\(\boldsymbol{x}\)</span> initialised at the ground truth.</p>
<div class="sourceCode" id="cb12" data-language="R"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="co"># Run and plot parameter output</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a> <span class="kw">set.seed</span>(<span class="dv">3421</span>)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a> out=<span class="kw">metropolis</span>(<span class="dv">50000</span>,ydata,V,B,<span class="kw">c</span>(<span class="dv">2</span>,<span class="kw">log</span>(<span class="fl">0.1</span>),<span class="kw">log</span>(<span class="fl">0.5</span>)),xs)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a><span class="co">##[1] 0.1357227 0.3749275</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a> </span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a> phiVec=<span class="kw">exp</span>(out[[<span class="dv">1</span>]][,<span class="dv">1</span>])<span class="op">/</span>(<span class="dv">1</span><span class="op">+</span><span class="kw">exp</span>(out[[<span class="dv">1</span>]][,<span class="dv">1</span>]))</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a> sigVec=<span class="kw">exp</span>(out[[<span class="dv">1</span>]][,<span class="dv">2</span>])</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a> kappaVec=<span class="kw">exp</span>(out[[<span class="dv">1</span>]][,<span class="dv">3</span>])</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a> </span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a> <span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">3</span>))</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a> <span class="kw">plot</span>(<span class="kw">ts</span>(phiVec),<span class="dt">main=</span><span class="st">&quot;phi&quot;</span>,<span class="dt">xlab=</span><span class="st">&quot;iteration&quot;</span>,<span class="dt">ylab=</span><span class="st">&quot;value&quot;</span>)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true"></a> <span class="kw">acf</span>(phiVec,<span class="dt">main=</span><span class="st">&quot;&quot;</span>,<span class="dt">lag.max=</span><span class="dv">100</span>)</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true"></a> <span class="kw">hist</span>(phiVec,<span class="dt">freq=</span>F,<span class="dt">main=</span><span class="st">&quot;phi&quot;</span>,<span class="dt">xlab=</span><span class="st">&quot;value&quot;</span>)</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true"></a> <span class="kw">plot</span>(<span class="kw">ts</span>(sigVec),<span class="dt">main=</span><span class="st">&quot;sigma&quot;</span>,<span class="dt">xlab=</span><span class="st">&quot;iteration&quot;</span>,<span class="dt">ylab=</span><span class="st">&quot;value&quot;</span>)</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true"></a> <span class="kw">acf</span>(sigVec,<span class="dt">main=</span><span class="st">&quot;&quot;</span>,<span class="dt">lag.max=</span><span class="dv">100</span>)</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true"></a> <span class="kw">hist</span>(sigVec,<span class="dt">freq=</span>F,<span class="dt">main=</span><span class="st">&quot;sigma&quot;</span>,<span class="dt">xlab=</span><span class="st">&quot;value&quot;</span>)</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true"></a> <span class="kw">plot</span>(<span class="kw">ts</span>(kappaVec),<span class="dt">main=</span><span class="st">&quot;kappa&quot;</span>,<span class="dt">xlab=</span><span class="st">&quot;iteration&quot;</span>,<span class="dt">ylab=</span><span class="st">&quot;value&quot;</span>)</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true"></a> <span class="kw">acf</span>(kappaVec,<span class="dt">main=</span><span class="st">&quot;&quot;</span>,<span class="dt">lag.max=</span><span class="dv">100</span>)</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true"></a> <span class="kw">hist</span>(kappaVec,<span class="dt">freq=</span>F,<span class="dt">main=</span><span class="st">&quot;kappa&quot;</span>,<span class="dt">xlab=</span><span class="st">&quot;value&quot;</span>)</span></code></pre></div>
<table id="fig:figApp2out" class="imageTable">
<caption>Application II. Metropolis sampler parameter output.</caption>
<tbody>
<tr class="odd">
<td style="text-align: center;"><embed src="../graphics/App2out1.pdf" title="fig:" id="fig:figApp2out" style="width:15cm;height:6cm" /></td>
</tr>
<tr class="even">
<td style="text-align: center;"><embed src="../graphics/App2out2.pdf" title="fig:" id="fig:figApp2out" style="width:15cm;height:6cm" /></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><embed src="../graphics/App2out3.pdf" title="fig:" id="fig:figApp2out" style="width:15cm;height:6cm" /></td>
</tr>
</tbody>
</table>
<p><strong>Remarks:</strong></p>
<ul>
<li><p>The effective sample sizes for logit <span class="math inline">\(\phi\)</span>, <span class="math inline">\(\log \sigma\)</span> and <span class="math inline">\(\log \kappa\)</span> are 499, 16 and 426, suggesting that a run of at least ten times the current length would be preferred.</p></li>
<li><p>The acceptance rates for the <span class="math inline">\(\boldsymbol{\theta}\)</span> and <span class="math inline">\(\boldsymbol{x}\)</span> updates are 0.14 and 0.37 (– a little high and low resp. Needs further tuning!)</p></li>
<li><p>The worst mixing chain is that for <span class="math inline">\(\theta_2=\log \sigma\)</span>. This is the <em>volatility of the volatility</em> parameter, and is well known to be hard to estimate.</p></li>
<li><p>We can summarise the marginal posterior distrubtion of the dynamic <span class="math inline">\(X_t\)</span> process at each time <span class="math inline">\(t\)</span> by computing the posterior mean and a <span class="math inline">\(95\%\)</span> equi-tailed credible interval via the follwong code.</p></li>
</ul>
<div class="sourceCode" id="cb13" data-language="R"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>xmean=<span class="kw">apply</span>(out[[<span class="dv">2</span>]],<span class="dv">2</span>,mean)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a> lq=<span class="kw">apply</span>(out[[<span class="dv">2</span>]],<span class="dv">2</span>,quantile,<span class="fl">0.025</span>) <span class="co">#lower 2.5 percentile</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a> uq=<span class="kw">apply</span>(out[[<span class="dv">2</span>]],<span class="dv">2</span>,quantile,<span class="fl">0.975</span>) <span class="co">#upper 2.5 percentile</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a> </span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a> <span class="kw">plot</span>(<span class="kw">ts</span>(xmean),<span class="dt">ylab=</span><span class="st">&quot;Xt&quot;</span>,<span class="dt">ylim=</span><span class="kw">c</span>(<span class="op">-</span><span class="dv">3</span>,<span class="dv">3</span>))</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a> <span class="kw">lines</span>(<span class="kw">ts</span>(lq))</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a> <span class="kw">lines</span>(<span class="kw">ts</span>(uq))</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a> <span class="kw">lines</span>(<span class="kw">ts</span>(xs),<span class="dt">col=</span><span class="dv">2</span>) <span class="co">#ground truth</span></span></code></pre></div>
<div class="center">
<figure>
<embed src="../graphics/App2out4.pdf" id="fig:figApp2out2" style="width:12cm;height:9cm" /><figcaption aria-hidden="true">Application II. Posterior mean and <span class="math inline">\(95\%\)</span> equi-tailed credible interval for <span class="math inline">\(X_t\)</span> against <span class="math inline">\(t\)</span>. The ground truth is the red line.</figcaption>
</figure>
</div>
</section>
</section>
</section>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>A thin of a factor <span class="math inline">\(k\)</span> means storing <span class="math inline">\(\boldsymbol{\theta}^{(k)}, \boldsymbol{\theta}^{(2k)},\ldots\)</span> It is typically used to reduce storage costs. Estimations based on the thinned chain are still valid, however, thinning throws away information.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
<script>
function doNumbering() {
	// The syntax to read the structured data from the yaml is horrible, template literals fix the problem but probably aren't widely supported enough. Escaping line breaks is browser dependant. I don't know if there's a better way?
	// Note that the data from the yaml file is manipulated into an array, and then parsed back into strings later, but I didn't want to deal with the pandoc templating syntax longer than necessary.
	var supportedEnvsArrayString = ' .definition;;; .theorem;;; .lemma;;; .example;;; .exampleqed;;; .proposition;;; .remark;;; .corollary;;; .exercise;;; .question';
	var supportedEnvsArray = supportedEnvsArrayString.split("|||");
	supportedEnvsArray = supportedEnvsArray.map(inner => inner.split(";;;"));
	var numberWithin = '1';
	var counterOffset = '';
	var subcounterOffset = '';
	var problemCounter = '';
	const partLabels = 'abcdefghijklmnopqrstuvwxyz'.split('');
	
	// counterOffset may be negative, and by default if specified on the command line this gets string concatenated with the default given in the yaml config and this then causes a problem. Can be fixed by removing the default in the config file and converting to an int, but this causes a NaN error if no value is suplied on the command line, so if NaN set to 0.
	counterOffset = parseInt(counterOffset);
	if (isNaN(counterOffset)) {
		counterOffset = 0;
	}
	
	subcounterOffset = parseInt(subcounterOffset);
	if (isNaN(subcounterOffset)) {
		subcounterOffset = 0;
	}
	
	problemCounter = parseInt(problemCounter);
	if (isNaN(problemCounter)) {
		problemCounter = 1;
	}
	
	function sanitiseSelector(selector) {
		// tex labels often have colons in which need escaping. There may be other escaping needed here. Unfortunately neither encodeURI nor encodeURIComponent do what I need, so use regex to do the escaping manually.
		var sanitised = selector.replace(/\:/g,"\\\:");
		sanitised = sanitised.replace(/(^[\d])/,"\\3$1 ");
		sanitised = sanitised.replace(/\//g,"\\\/");
		return sanitised
	}
	
	function labelLinks() {
		var refs = document.querySelectorAll("a[data-reference-type=ref]")
		for (ref of refs) {
			// Escape colons (or other) from the link title.
			var ref_label = sanitiseSelector(ref.getAttribute("data-reference"));
			// Hopefully ref is a reference to a div or a section, which should have the associated id. If so, we just need the data-number from the relevant DOM item.
			var ref_to = document.querySelector("#"+ref_label);
			if (ref_to !== null) {
				var ref_number = ref_to.getAttribute("data-number");
			} else {
				// If ref is being used for an equation, then we need to try to parse the mathjax divs. This is fragile, but try to find the span which corresponds to the equation number we need.
				try {
					var mathjax_ref = "#mjx-eqn-"+ref_label;
					ref_to = document.querySelector(mathjax_ref);
					// Since this is a ref, we don't want the parens to be returned, so find the equation number and strip the parens.
					var ref_number = ref_to.querySelector(".mjx-char").innerHTML.replace(/[()]/g,"");
					ref.setAttribute("href",mathjax_ref);
				}
				// If we can't find a place to link to, just indicate a missing link.
				catch (err){
					var ref_number = "???"
				}
			}
			ref.innerHTML = ref_number;
		};
	}
	
	function numberEnvs() {
		for (var levelSpec = 0; levelSpec <= numberWithin; levelSpec++) {
			var reqLevels = document.querySelectorAll(".level"+levelSpec);
			for (var level of reqLevels) {
				levelCount = level.getAttribute("data-number");
				levelCount = String(parseFloat(levelCount)+(counterOffset));
				levelCount = levelCount+(("."+subcounterOffset).repeat(numberWithin-levelSpec));
				for (var counter of supportedEnvsArray) {
					var envCount = 1;
					var envs = level.querySelectorAll(counter.join(", "));
					for (var env of envs) {
						env.setAttribute("data-number",levelCount+"."+envCount);
						envCount += 1;
					}
				}
			}
		}
	}
	
	function numberFigs() {
		// Figures should either be in a figure environment, or a table with image class imageTable thanks to the tableCaps filter.
		figs = document.querySelectorAll("figure, .imageTable");
		var fig_no = 1
		for (var fig of figs) {
			var cap
			// For figures, we want to move the id to the figure, and set the data-number on both the figure and the figcaption
			if (fig.nodeName == "FIGURE") {
				cap = fig.querySelector("figcaption");
				var img = fig.querySelector("img, embed")
				if (img) {
					var img_id = img.getAttribute("id");
					fig.setAttribute("id",img_id);
					img.removeAttribute("id");
				}
			// for tables (which must be .imageTable due to the querySelector above), we want to set the data-number on the table and the caption
			} else if (fig.nodeName == "TABLE") {
				cap = fig.querySelector("caption");
			}
			cap.setAttribute("data-number",fig_no);
			fig.setAttribute("data-number",fig_no);
			fig_no += 1;
		}
	}
	
	function numberGlobals() {
		// This function numbers any environments that just use a global counter, such as a problem number on a problems sheet, where there are no sections to number with respect to.
		probsols = document.querySelectorAll(".problem, .solution");
		var prob_no = problemCounter;
		var partNo = 0;
		for (var probsol of probsols) {
			if (probsol.className == "problem"){
				prob_no +=1;
				partNo = 0;
				probsol.setAttribute("data-number",prob_no);
			}
			else {
				if (probsol.parentNode.nodeName == "LI") {
					var partLabel = partLabels[partNo];
					probsol.setAttribute("data-number",prob_no.toString()+partLabel);
					partNo +=1;
				}
				else{
					probsol.setAttribute("data-number",prob_no);
				}
			}
			
		}
		// sols = document.querySelectorAll(".solution");
// 		var sol_no = problemCounter;
// 		for (var sol of sols) {
// 			sol.setAttribute("data-number",sol_no);
// 			sol_no +=1
// 		}
	}
	
	// labelLinks() should occur last, so that the data-numbers have been correctly set first.
	numberEnvs();
	numberFigs();
	numberGlobals();
	labelLinks();
}
</script><script>
	var imageDir = ''
	imgs = document.querySelectorAll("img");
	for (var img of imgs) {
		imgsrc = img.getAttribute("src");
		img.setAttribute("src",imageDir.concat(imgsrc));
	}
</script></body>
</html>
